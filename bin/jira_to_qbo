#!/usr/bin/env ruby

require 'yaml'
require 'jira'
require 'json'
require 'colorize'
require 'date'
require 'jira_to_qbo'

opts = YAML.load(
  File.read(
    File.join(
      ENV['HOME'],
      ".#{File.basename(__FILE__, '.*')}.yaml"
    )
  )
)

# Go thru all jiras and collect task work logs
work_log = opts['jiras'].map do |jira|
  client = JIRA::Client.new(
    username: jira['username'],
    password: jira['password'],
    site: jira['endpoint'],
    context_path: '',
    auth_type: :basic)

  jira['projects'].map do |project|
    # Go thru all projects hosted on the jira
    client.Issue.jql(
      "project = #{project['key']} AND updated >= -15h",
      fields: %w(key summary)
    ).map do |issue|
      # Go thru all issues for the project that were updated for last 15 hours
      JSON.parse(
        client.get(JIRA::Resource::Worklog.collection_path(client, "/issue/#{issue.id}/")).body
      )['worklogs'].reverse.map do |worklog|
        # Go thru all work logs for the issue
        next unless worklog['author']['name'] == jira['username']
        next unless \
          DateTime.parse(worklog['updated']) + (15.to_r / 24) > \
          Time.now.to_datetime

        print "#{worklog['updated']}\t#{worklog['timeSpent']}\n" \
          "#{issue.key} #{issue.summary}\n#{worklog['comment']}\n"

        puts '-'.bold.white

        task_comments = JSON.parse(
          client.get(JIRA::Resource::Comment.collection_path(client, "/issue/#{issue.id}/"))
            .body
        )['comments'].map do |comment|
          next unless \
          DateTime.parse(comment['updated']) + (15.to_r / 24) > \
          Time.now.to_datetime

          {
            message: comment['body'],
            time: comment['updated'],
            author: comment['author']['key']
          }
        end.compact

        {
          message: "#{issue.key} #{issue.summary}\n#{worklog['comment']}",
          time: worklog['timeSpent'],
          comments: task_comments
        }
      end.compact
    end
  end
end.flatten

JiraToQbo::EmailReport.new(work_log,
                           pm_name: opts['pm_name'],
                           email_signature: opts['email_signature'])
  .send(rcpt: opts['to'],
        cc: opts['cc'],
        from: opts['from'],
        smtp_username: opts['smtp_username'],
        smtp_password: opts['smtp_password'],
        smtp_host: opts['smtp_host'])
